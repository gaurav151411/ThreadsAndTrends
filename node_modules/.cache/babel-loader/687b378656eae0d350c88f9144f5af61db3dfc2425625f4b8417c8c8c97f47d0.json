{"ast":null,"code":"/*\n  Transformation rules for Brill's POS tagger\n  Copyright (C) 2015 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Usage: \n// transformationRules = new BrillTransformationRules();\n// transformationRules.rules.forEach(function(ruleFunction) {\n//   ruleFunction(taggedSentence, i);\n// });\n// where taggedSentence is an array of arrays of the form:\n// [[the, DET], [red, JJ], [book, NN]] and i the position to be processed\n\nfunction BrillTransformationRules() {\n  this.rules = [rule1, rule2, rule3, rule4, rule5, rule6, rule7, rule8];\n}\nBrillTransformationRules.prototype.getRule = function (index) {\n  return this.rules[index];\n};\nBrillTransformationRules.prototype.setRule = function (index, rule) {\n  this.rules[index] = rule;\n};\nBrillTransformationRules.prototype.appendRule = function (rule) {\n  this.rules[this.rules.length] = rule;\n};\nBrillTransformationRules.prototype.setRules = function (newRules) {\n  this.rules = newRules;\n};\nBrillTransformationRules.prototype.getRules = function () {\n  return this.rules;\n};\n\n/**\n * Indicates whether or not this string starts with the specified string.\n * @param {Object} string\n */\nfunction startsWith($this, string) {\n  if (!string) {\n    return false;\n  }\n  return $this.indexOf(string) == 0;\n}\n\n/**\n * Indicates whether or not this string ends with the specified string.\n * @param {Object} string\n */\nfunction endsWith($this, string) {\n  if (!string || string.length > $this.length) {\n    return false;\n  }\n  return $this.indexOf(string) == $this.length - string.length;\n}\n\n//  rule 1: DT, {VBD | VBP} --> DT, NN\nfunction rule1(taggedSentence, index) {\n  if (index > 0 && taggedSentence[index - 1][1] === \"DT\") {\n    if (taggedSentence[index][1] === \"VBD\" || taggedSentence[index][1] === \"VBP\" || taggedSentence[index][1] === \"VB\") {\n      taggedSentence[index][1] = \"NN\";\n    }\n  }\n}\n\n// rule 2: convert a noun to a number (CD) if \".\" appears in the word\nfunction rule2(taggedSentence, index) {\n  if (startsWith(taggedSentence[index][1], \"N\")) {\n    if (taggedSentence[index][0].indexOf(\".\") > -1) {\n      // url if there are two contiguous alpha characters\n      if (/[a-zA-Z]{2}/.test(taggedSentence[index][0])) {\n        taggedSentence[index][1] = \"URL\";\n      } else {\n        taggedSentence[index][1] = \"CD\";\n      }\n    }\n    // Attempt to convert into a number\n    if (!isNaN(parseFloat(taggedSentence[index][0]))) {\n      taggedSentence[index][1] = \"CD\";\n    }\n  }\n}\n\n// rule 3: convert a noun to a past participle if words[i] ends with \"ed\"\nfunction rule3(taggedSentence, index) {\n  if (startsWith(taggedSentence[index][1], \"N\") && endsWith(taggedSentence[index][0], \"ed\")) {\n    taggedSentence[index][1] = \"VBN\";\n  }\n}\n\n// rule 4: convert any type to adverb if it ends in \"ly\";\nfunction rule4(taggedSentence, index) {\n  if (endsWith(taggedSentence[index][0], \"ly\")) {\n    taggedSentence[index][1] = \"RB\";\n  }\n}\n\n// rule 5: convert a common noun (NN or NNS) to a adjective if it ends with \"al\"\nfunction rule5(taggedSentence, index) {\n  if (startsWith(taggedSentence[index][1], \"NN\") && endsWith(taggedSentence[index][0], \"al\")) {\n    taggedSentence[index][1] = \"JJ\";\n  }\n}\n\n// rule 6: convert a noun to a verb if the preceding work is \"would\"\nfunction rule6(taggedSentence, index) {\n  if (index > 0 && startsWith(taggedSentence[index][1], \"NN\") && taggedSentence[index - 1][0].toLowerCase() === \"would\") {\n    taggedSentence[index][1] = \"VB\";\n  }\n}\n\n// rule 7: if a word has been categorized as a common noun and it ends with \"s\",\n//         then set its type to plural common noun (NNS)\nfunction rule7(taggedSentence, index) {\n  if (taggedSentence[index][1] === \"NN\" && endsWith(taggedSentence[index][0], \"s\")) {\n    taggedSentence[index][1] = \"NNS\";\n  }\n}\n\n// rule 8: convert a common noun to a present participle verb (i.e., a gerund)\nfunction rule8(taggedSentence, index) {\n  if (startsWith(taggedSentence[index][1], \"NN\") && endsWith(taggedSentence[index][0], \"ing\")) {\n    taggedSentence[index][1] = \"VBG\";\n  }\n}\nmodule.exports = BrillTransformationRules;","map":{"version":3,"names":["BrillTransformationRules","rules","rule1","rule2","rule3","rule4","rule5","rule6","rule7","rule8","prototype","getRule","index","setRule","rule","appendRule","length","setRules","newRules","getRules","startsWith","$this","string","indexOf","endsWith","taggedSentence","test","isNaN","parseFloat","toLowerCase","module","exports"],"sources":["/Users/gauravsain/Desktop/PEPCODING/DEV/React/threadsandtrends/node_modules/pos/BrillTransformationRules.js"],"sourcesContent":["/*\n  Transformation rules for Brill's POS tagger\n  Copyright (C) 2015 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Usage: \n// transformationRules = new BrillTransformationRules();\n// transformationRules.rules.forEach(function(ruleFunction) {\n//   ruleFunction(taggedSentence, i);\n// });\n// where taggedSentence is an array of arrays of the form:\n// [[the, DET], [red, JJ], [book, NN]] and i the position to be processed\n\nfunction BrillTransformationRules() {\n  this.rules = [rule1, rule2, rule3, rule4, rule5, rule6, rule7, rule8];\n}\n\nBrillTransformationRules.prototype.getRule = function(index) {\n  return(this.rules[index]);\n};\n\nBrillTransformationRules.prototype.setRule = function(index, rule) {\n  this.rules[index] = rule;\n};\n\nBrillTransformationRules.prototype.appendRule = function(rule) {\n  this.rules[this.rules.length] = rule;\n};\n\nBrillTransformationRules.prototype.setRules = function(newRules) {\n  this.rules = newRules;\n};\n\nBrillTransformationRules.prototype.getRules = function() {\n  return(this.rules);\n};\n\n/**\n * Indicates whether or not this string starts with the specified string.\n * @param {Object} string\n */\nfunction startsWith($this, string) {\n  if (!string) {\n    return false;\n  }\n  return $this.indexOf(string) == 0;\n}\n\n/**\n * Indicates whether or not this string ends with the specified string.\n * @param {Object} string\n */\nfunction endsWith($this, string) {\n  if (!string || string.length > $this.length) {\n    return false;\n  }\n  return $this.indexOf(string) == $this.length - string.length;\n}\n\n//  rule 1: DT, {VBD | VBP} --> DT, NN\nfunction rule1(taggedSentence, index) {\n  if ((index > 0) && (taggedSentence[index - 1][1] === \"DT\")) {\n    if ((taggedSentence[index][1] === \"VBD\") ||\n      (taggedSentence[index][1] === \"VBP\") ||\n      (taggedSentence[index][1] === \"VB\")) {\n      taggedSentence[index][1] = \"NN\";\n    }\n  }\n}\n\n// rule 2: convert a noun to a number (CD) if \".\" appears in the word\nfunction rule2(taggedSentence, index) {\n  if (startsWith(taggedSentence[index][1], \"N\")) {\n    if (taggedSentence[index][0].indexOf(\".\") > -1) {\n      // url if there are two contiguous alpha characters\n      if (/[a-zA-Z]{2}/.test(taggedSentence[index][0])) {\n        taggedSentence[index][1] = \"URL\";\n      }\n      else {\n        taggedSentence[index][1] = \"CD\";\n      }\n    }\n    // Attempt to convert into a number\n    if (!isNaN(parseFloat(taggedSentence[index][0]))) {\n      taggedSentence[index][1] = \"CD\";\n    }\n  }\n}\n\n// rule 3: convert a noun to a past participle if words[i] ends with \"ed\"\nfunction rule3(taggedSentence, index) {\n  if (startsWith(taggedSentence[index][1], \"N\") && endsWith(taggedSentence[index][0], \"ed\")) {\n    taggedSentence[index][1] = \"VBN\";\n  }\n}\n\n// rule 4: convert any type to adverb if it ends in \"ly\";\nfunction rule4(taggedSentence, index) {\n  if (endsWith(taggedSentence[index][0], \"ly\")) {\n    taggedSentence[index][1] = \"RB\";\n  }\n}\n\n// rule 5: convert a common noun (NN or NNS) to a adjective if it ends with \"al\"\nfunction rule5(taggedSentence, index) {\n  if (startsWith(taggedSentence[index][1], \"NN\") && endsWith(taggedSentence[index][0], \"al\")) {\n    taggedSentence[index][1] = \"JJ\";\n  }\n}\n\n// rule 6: convert a noun to a verb if the preceding work is \"would\"\nfunction rule6(taggedSentence, index) {\n  if ((index > 0) && startsWith(taggedSentence[index][1], \"NN\") && (taggedSentence[index - 1][0].toLowerCase() === \"would\")) {\n    taggedSentence[index][1] = \"VB\";\n  }\n}\n\n// rule 7: if a word has been categorized as a common noun and it ends with \"s\",\n//         then set its type to plural common noun (NNS)\nfunction rule7(taggedSentence, index) {\n  if ((taggedSentence[index][1] === \"NN\") && (endsWith(taggedSentence[index][0], \"s\"))) {\n    taggedSentence[index][1] = \"NNS\";\n  }\n}\n\n// rule 8: convert a common noun to a present participle verb (i.e., a gerund)\nfunction rule8(taggedSentence, index) {\n  if (startsWith(taggedSentence[index][1], \"NN\") && endsWith(taggedSentence[index][0], \"ing\")) {\n    taggedSentence[index][1] = \"VBG\";\n  }\n}\n\nmodule.exports = BrillTransformationRules;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*!\n * jsPOS\n *\n * Copyright 2010, Percy Wegmann\n * Licensed under the LGPLv3 license\n * http://www.opensource.org/licenses/lgpl-3.0.html\n */\n\nvar TransformationRules = require('./BrillTransformationRules');\nvar transformationRules = new TransformationRules();\nmodule.exports = POSTagger;\nfunction POSTagger() {\n  this.lexicon = require('./lexicon');\n}\nPOSTagger.prototype.wordInLexicon = function (word) {\n  var ss = this.lexicon[word];\n  if (ss != null) return true;\n  // 1/22/2002 mod (from Lisp code): if not in hash, try lower case:\n  if (!ss) ss = this.lexicon[word.toLowerCase()];\n  if (ss) return true;\n  return false;\n};\nPOSTagger.prototype.tag = function (words) {\n  var taggedSentence = new Array(words.length);\n\n  // Initialise taggedSentence with words and initial categories\n  for (var i = 0, size = words.length; i < size; i++) {\n    taggedSentence[i] = new Array(2);\n    taggedSentence[i][0] = words[i];\n    // lexicon maps a word to an array of possible categories\n    var ss = this.lexicon[words[i]];\n    // 1/22/2002 mod (from Lisp code): if not in hash, try lower case:\n    if (!ss) ss = this.lexicon[words[i].toLowerCase()];\n    if (!ss && words[i].length === 1) taggedSentence[i][1] = words[i] + \"^\";\n    // We need to catch scenarios where we pass things on the prototype\n    // that aren't in the lexicon: \"constructor\" breaks this otherwise\n    if (!ss || Object.prototype.toString.call(ss) !== '[object Array]') taggedSentence[i][1] = \"NN\";else taggedSentence[i][1] = ss[0];\n  }\n\n  // Apply transformation rules\n  taggedSentence.forEach(function (taggedWord, index) {\n    transformationRules.getRules().forEach(function (rule) {\n      rule(taggedSentence, index);\n    });\n  });\n  return taggedSentence;\n};\nPOSTagger.prototype.prettyPrint = function (taggedWords) {\n  for (i in taggedWords) {\n    print(taggedWords[i][0] + \"(\" + taggedWords[i][1] + \")\");\n  }\n};\nPOSTagger.prototype.extendLexicon = function (lexicon) {\n  for (var word in lexicon) {\n    if (!this.lexicon.hasOwnProperty(word)) {\n      this.lexicon[word] = lexicon[word];\n    }\n  }\n};\n\n// console.log(new POSTagger().tag([\"i\", \"went\", \"to\", \"the\", \"store\", \"to\", \"buy\", \"5.2\", \"gallons\", \"of\", \"milk\"]));","map":{"version":3,"names":["TransformationRules","require","transformationRules","module","exports","POSTagger","lexicon","prototype","wordInLexicon","word","ss","toLowerCase","tag","words","taggedSentence","Array","length","i","size","Object","toString","call","forEach","taggedWord","index","getRules","rule","prettyPrint","taggedWords","print","extendLexicon","hasOwnProperty"],"sources":["/Users/gauravsain/Desktop/PEPCODING/DEV/React/threadsandtrends/node_modules/pos/POSTagger.js"],"sourcesContent":["/*!\n * jsPOS\n *\n * Copyright 2010, Percy Wegmann\n * Licensed under the LGPLv3 license\n * http://www.opensource.org/licenses/lgpl-3.0.html\n */\n\nvar TransformationRules = require('./BrillTransformationRules');\nvar transformationRules = new TransformationRules();\n\nmodule.exports = POSTagger;\nfunction POSTagger(){\n    this.lexicon = require('./lexicon');\n}\n\nPOSTagger.prototype.wordInLexicon = function(word){\n    var ss = this.lexicon[word];\n    if (ss != null)\n        return true;\n    // 1/22/2002 mod (from Lisp code): if not in hash, try lower case:\n    if (!ss)\n        ss = this.lexicon[word.toLowerCase()];\n    if (ss)\n        return true;\n    return false;\n}\n\nPOSTagger.prototype.tag = function(words) {\n  var taggedSentence = new Array(words.length);\n\n  // Initialise taggedSentence with words and initial categories\n  for (var i = 0, size = words.length; i < size; i++) {\n    taggedSentence[i] = new Array(2);\n    taggedSentence[i][0] = words[i];\n    // lexicon maps a word to an array of possible categories\n    var ss = this.lexicon[words[i]];\n    // 1/22/2002 mod (from Lisp code): if not in hash, try lower case:\n    if (!ss)\n      ss = this.lexicon[words[i].toLowerCase()];\n    if (!ss && (words[i].length === 1))\n      taggedSentence[i][1] = words[i] + \"^\";\n    // We need to catch scenarios where we pass things on the prototype\n    // that aren't in the lexicon: \"constructor\" breaks this otherwise\n    if (!ss || (Object.prototype.toString.call(ss) !== '[object Array]'))\n      taggedSentence[i][1] = \"NN\";\n    else\n      taggedSentence[i][1] = ss[0];\n  }\n\n  // Apply transformation rules\n  taggedSentence.forEach(function(taggedWord, index) {\n    transformationRules.getRules().forEach(function(rule) {\n      rule(taggedSentence, index);\n    });\n  });\n  return taggedSentence;\n}\n\nPOSTagger.prototype.prettyPrint = function(taggedWords) {\n\tfor (i in taggedWords) {\n        print(taggedWords[i][0] + \"(\" + taggedWords[i][1] + \")\");\n    }\n}\n\nPOSTagger.prototype.extendLexicon = function(lexicon) {\n  for (var word in lexicon) {\n    if (!this.lexicon.hasOwnProperty(word)) {\n      this.lexicon[word] = lexicon[word];\n    }\n  }\n}\n\n// console.log(new POSTagger().tag([\"i\", \"went\", \"to\", \"the\", \"store\", \"to\", \"buy\", \"5.2\", \"gallons\", \"of\", \"milk\"]));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}